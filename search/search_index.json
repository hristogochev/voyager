{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":""},{"location":"#vortex-spin-up-your-compose-navigation","title":"Vortex: Spin up your Compose Navigation","text":"<p>Stability-focused Compose Multiplatform Navigation Library, fork of Voyager.</p> <p>Vortex maintains nearly the same API as Voyager, ensuring seamless integration:</p> <pre><code>class HomeScreenModel : ScreenModel {\n    // ...\n}\n\ndata object HomeScreen : Screen {\n\n    @Composable\n    override fun Content() {\n        val screenModel = rememberScreenModel&lt;HomeScreenModel&gt;()\n        // ...\n    }\n}\n\n\n@Composable\nfun App() {\n    Navigator(HomeScreen)\n}\n</code></pre>"},{"location":"#features","title":"Features","text":"<ul> <li>Supported platforms: Android, iOS, Desktop, Wasm, JS</li> <li>Basic navigation</li> <li>Nested navigation</li> <li>Bottom sheet navigation</li> <li>Advanced navigation</li> <li>Tab navigation (like bottom navigation)</li> <li>ScreenModel (Multiplatform ViewModel)</li> <li>Transitions per screen</li> <li>State restoration after Activity recreation</li> <li>Callbacks for screen creation and disposal</li> <li>Deep linking support</li> <li>State-aware Stack API</li> </ul>"},{"location":"#differences-with-voyager","title":"Differences with Voyager","text":""},{"location":"#navigation","title":"Navigation","text":"<ul> <li>Navigator-Screen Linking:Navigators are now directly linked to their parent screen instead of their parent navigator.  </li> <li>Automatic Disposal:When a screen is disposed, all navigators within it are automatically disposed.  </li> <li>Flexible Bottom Sheet Navigation:Bottom sheet navigation can now be used in any bottom sheet.</li> <li>Simplified Bottom Sheet Navigators: Bottom sheet navigators have been streamlined into simple navigators with a <code>disposeOnForgotten</code> flag.</li> </ul>"},{"location":"#transitions","title":"Transitions","text":"<ul> <li>Navigator Default Transitions:You can specify default navigator overridable screen appear and disappear transitions.</li> <li>Runtime Appear Transition:You can specify the appear transition for a screen at runtime.  </li> <li>Runtime Disappear Transition:You can specify the disappear transition for a screen at runtime.</li> </ul>"},{"location":"#lifecycle","title":"Lifecycle","text":"<ul> <li>Screen Disposable Effect:A new screen disposable effect is available, tied to the lifecycle of the screen.</li> <li>Reliable Application Lifecycle Owner:You can now reliably access the application\u2019s multiplatform lifecycle owner without risk of failure to update.  </li> </ul>"},{"location":"#missing-features","title":"Missing features","text":"<ul> <li>Android specific state management:No support for Android-specific APIs, such as LiveData, Hilt, and RxJava.</li> <li>No screen-specific lifecycle owners:Screens no longer override the default LocalLifecycleOwner.</li> <li>No screen registry:Unlike Voyager, Vortex does not provide a screen registry.</li> </ul>"},{"location":"#acknowledgments","title":"Acknowledgments","text":"<ul> <li>Big thanks to Adriel Caf\u00e9 and all contributors of the original Voyager library.</li> </ul>"},{"location":"deep-links/","title":"Deep links","text":"<p>Warning</p> <p>Currently, Vortex does not provide a built-in solution to handle Deeplink and URIs. see issues #149 and #382 of Voyager.</p> <p>You can initialize the <code>Navigator</code> with multiple screens, that way, the first visible screen will be the last one and will be possible to return (<code>pop()</code>) to the previous screens.</p> <pre><code>val postId = getPostIdFromIntent()\n\nsetContent {\n    Navigator(\n        HomeScreen,\n        PostListScreen(),\n        PostDetailsScreen(postId)\n    )\n}\n</code></pre>"},{"location":"lifecycle/","title":"Lifecycle","text":"<p>Inside a <code>Screen</code>, you can call <code>ScreenDisposableEffect</code> to execute a block of code  the first time a <code>Screen</code> appears or any of its keys change.</p> <p>You can also execute a block of code  when the <code>Screen</code> gets disposed or any of its keys change using the <code>onDispose</code> callback.</p> <pre><code>data object HomeScreen : Screen {\n\n    @Composable\n    override fun Content() {\n\n        ScreenDisposableEffect {\n            println(\"Created home screen\")\n            onDispose {\n                println(\"Disposed of home screen\")\n            }\n        }\n\n        val counter = remember { 1 }\n\n        ScreenDisposableEffect(counter) {\n            println(\"Counter: $counter\")\n            onDispose {\n                println(\"Counter changed\")\n            }\n        }\n\n        val lifecycleOwner = LocalLifecycleOwner.current\n\n        ScreenDisposableEffect(lifecycleOwner) {\n            val observer = LifecycleEventObserver { _, event -&gt;\n                when (event) {\n                    Lifecycle.Event.ON_CREATE -&gt; {\n                        println(\"On create\")\n                    }\n\n                    Lifecycle.Event.ON_START -&gt; {\n                        println(\"On start\")\n                    }\n\n                    Lifecycle.Event.ON_RESUME -&gt; {\n                        println(\"On resume\")\n                    }\n\n                    Lifecycle.Event.ON_PAUSE -&gt; {\n                        println(\"On pause\")\n                    }\n\n                    Lifecycle.Event.ON_STOP -&gt; {\n                        println(\"On stop\")\n                    }\n\n                    Lifecycle.Event.ON_DESTROY -&gt; {\n                        println(\"On destroy\")\n                    }\n\n                    else -&gt; {}\n                }\n            }\n\n            lifecycleOwner.lifecycle.addObserver(observer)\n            onDispose {\n                lifecycleOwner.lifecycle.removeObserver(observer)\n            }\n        }\n        // ...\n    }\n}\n</code></pre> <p>You can find source code for a working example here.</p>"},{"location":"setup/","title":"Setup","text":"<ol> <li> <p>Add Maven Central to your repositories if needed</p> <pre><code>repositories {\n    mavenCentral()\n}\n</code></pre> </li> <li> <p>Add the desired dependencies to your module\u2019s <code>build.gradle</code> file</p> </li> </ol> DependenciesVersion Catalog <pre><code>val vortexVersion = \"0.1.2\"\n\n// Main library\nimplementation(\"io.github.hristogochev:vortex:$vortexVersion\")\n\n// Koin integration\nimplementation(\"io.github.hristogochev:vortex-koin:$vortexVersion\")\n\n// Kodein integration\nimplementation(\"io.github.hristogochev:vortex-kodein:$vortexVersion\")\n</code></pre> <pre><code>[versions]\nvortex = \"0.1.2\"\n\n[libraries]\n// Main library\nvortex = { module = \"io.github.hristogochev:vortex\", version.ref = \"vortex\" }\n\n// Koin integration\nvortex-koin = { module = \"io.github.hristogochev:vortex-koin\", version.ref = \"vortex\" }\n\n// Kodein integration\nvortex-kodein = { module = \"io.github.hristogochev:vortex-kodein\", version.ref = \"vortex\" }\n</code></pre> <p>Current version here.</p>"},{"location":"stack-api/","title":"Stack API","text":""},{"location":"stack-api/#snapshotstatestack","title":"SnapshotStateStack","text":"<p>Vortex is backed by a SnapshotStateStack:</p> <ul> <li>Implementation of Stack that can be observed and snapshot</li> <li>Internally uses a SnapshotStateList</li> <li>State-aware: content change triggers a recomposition</li> </ul> <p>You will use it to navigate forward (<code>push</code>, <code>replace</code>, <code>replaceAll</code>) and backwards (<code>pop</code>, <code>popAll</code>, <code>popUntil</code>), but the <code>SnapshotStateStack</code> can also be used as a regular collection outside the <code>Navigator</code>.</p> <pre><code>val stack = mutableStateStackOf(\"\ud83c\udf47\", \"\ud83c\udf49\", \"\ud83c\udf4c\", \"\ud83c\udf50\", \"\ud83e\udd5d\", \"\ud83c\udf4b\")\n// \ud83c\udf47, \ud83c\udf49, \ud83c\udf4c, \ud83c\udf50, \ud83e\udd5d, \ud83c\udf4b\n\nstack.lastItemOrNull\n// \ud83c\udf4b\n\nstack.push(\"\ud83c\udf4d\")\n// \ud83c\udf47, \ud83c\udf49, \ud83c\udf4c, \ud83c\udf50, \ud83e\udd5d, \ud83c\udf4b, \ud83c\udf4d\n\nstack.pop()\n// \ud83c\udf47, \ud83c\udf49, \ud83c\udf4c, \ud83c\udf50, \ud83e\udd5d, \ud83c\udf4b\n\nstack.popUntil { it == \"\ud83c\udf50\" }\n// \ud83c\udf47, \ud83c\udf49, \ud83c\udf4c, \ud83c\udf50\n\nstack.replace(\"\ud83c\udf53\")\n// \ud83c\udf47, \ud83c\udf49, \ud83c\udf4c, \ud83c\udf53\n\nstack.replaceAll(\"\ud83c\udf52\")\n// \ud83c\udf52\n</code></pre> <p>You can also create a <code>SnapshotStateStack</code> through <code>rememberStateStack()</code>, it will restore the values after Activity recreation.</p>"},{"location":"stack-api/#events","title":"Events","text":"<p>Whenever the content changes, the <code>SnapshotStateStack</code> will emit a <code>StackEvent</code>. Use the <code>stack.lastEvent</code> to get the most recent one.</p> <p>The available events are:</p> <ul> <li><code>Push</code>: whenever <code>push</code> is called</li> <li><code>Replace</code>: whenever <code>replace</code> and <code>replaceAll</code> are called</li> <li><code>Pop</code>: whenever <code>pop</code> and <code>popAll</code> are called</li> <li><code>Idle</code>: default event</li> </ul> <p>You can find source code for a working example here.</p>"},{"location":"state-restoration/","title":"State restoration","text":"<p>Every instance of <code>Screen</code> is expected to be savable in a Bundle, therefore all params and properties of your <code>Screen</code> implementations should be either <code>Java Serializable</code> or <code>Parcelable</code>. Otherwise, your app will crash upon attempting to restore its state.</p> <p>Keep in mind that <code>Parcelables</code> are not <code>Java Serializable</code> by default and <code>Java Serializables</code> are not <code>Parcelable</code> by default.</p>"},{"location":"state-restoration/#java-serializable","title":"Java Serializable","text":"<pre><code>// \u2714\ufe0f DO\ndata class Post(/*...*/) : java.io.Serializable\n\ndata class ValidScreen(\n    val userId: Long, // Built-in serializable types\n    val post: Post // Your own serializable types\n) : Screen {\n\n    // Serializable properties\n    val tag = \"ValidScreen\"\n\n    // Lazily initialized serializable types\n    val randomId by lazy { UUID.randomUUID() }\n\n    // ...\n}\n\n// \ud83d\udeab DON'T\nclass Post(/*...*/)\n\ndata class InvalidScreen(\n    val context: Context, // Built-in non-serializable types\n    val post: Post, // Your own non-serializable types\n    val parcelable: SomeParcelable // Android Parcelable is not Java Serializable by default\n) : Screen {\n\n    // Non-serializable properties\n    val postService = PostService()\n\n    // ...\n}\n</code></pre>"},{"location":"state-restoration/#android-parcelables","title":"Android Parcelables","text":"<pre><code>// \u2714\ufe0f DO\n@Parcelize\ndata class Post(/*...*/) : Parcelable\n\n@Parcelize\ndata class ValidScreen(\n    val post: Post // Your own parcelable types\n) : Screen, Parcelable {\n    // ...\n}\n\n// \ud83d\udeab DON'T\nclass Post(/*...*/)\n\n@Parcelize\ndata class InvalidScreen(\n    val context: Context, // Built-in non-parcelable types\n    val post: Post, // Your own non-parcelable types\n    val serializable: SomeSerializable // Java Serializable are not Android Parcelable by default\n) : Screen, Parcelable {\n    // ...\n}\n</code></pre>"},{"location":"state-restoration/#enforcing-android-parcelable-on-your-screens","title":"Enforcing Android Parcelable on your screens","text":"<p>You can build your own Screen type for enforcing in at compile time that all yours screens should be Parcelable by creating an interface that implement Parcelable.</p> <pre><code>interface ParcelableScreen : Screen, Parcelable\n\n// Compile\n@Parcelize\ndata class Post(/*...*/) : Parcelable\n\n@Parcelize\ndata class ValidScreen(\n    val post: Post\n) : ParcelableScreen {\n    // ...\n}\n\n// Not compile\ndata class Post(/*...*/)\n\n@Parcelize\ndata class ValidScreen(\n    val post: Post\n) : ParcelableScreen {\n    // ...\n}\n</code></pre>"},{"location":"state-restoration/#multiplatform-state-restoration","title":"Multiplatform state restoration","text":"<p>When working in a Multiplatform project you may need a common <code>Java Serializable</code> or <code>Parcelable</code> interface/annotation, you can create one like this:</p> <pre><code>// commonMain - module core\nexpect interface JavaSerializable\n\n// androidMain - module core\nactual typealias JavaSerializable = java.io.Serializable\n\n// non AndroidMain (ios, web, etc) - module core\nactual interface JavaSerializable\n</code></pre>"},{"location":"state-restoration/#identifying-screens","title":"Identifying screens","text":"<p>The <code>Screen</code> interface has a <code>key</code> property that defines it in each <code>Navigator</code>. The default key for a <code>Screen</code> is its name. You can override it to set your own key.</p> <pre><code>data class HomeScreen(\n    override val key: String = \"CUSTOM_KEY\"\n) : Screen {\n\n    @Composable\n    override fun Content() {\n        // ...\n    }\n}\n</code></pre> <p>Vortex also has a <code>uniqueScreenKey</code> function, that generates a random key.</p> <pre><code>override val key = uniqueScreenKey()\n</code></pre> <p>Warning</p> <p>You should always set your own key, if the screen is used multiple times in the same <code>Navigator</code>, or is an anonymous or local class.</p>"},{"location":"transitions/","title":"Transitions","text":""},{"location":"transitions/#default-transitions","title":"Default transitions","text":"<p>You can specify the default <code>appear</code> and <code>disappear</code> transitions for every <code>Screen</code> in a <code>Navigator</code>.</p> <p>Vortex comes bundled with a set of a few transitions you can use for your apps.You can check them out here.</p> <p>In this example we will be using FadeTransition.</p> <pre><code>@Composable\nfun App(){\n    Navigator(HomeScreen) { navigator -&gt;\n        CurrentScreen(\n            navigator = navigator,\n            defaultOnScreenAppearTransition = FadeTransition,\n            defaultOnScreenDisappearTransition = FadeTransition\n        )\n    }\n}\n</code></pre> <p>This will make it so that the default fade transition will play everytime a new screen is pushed or popped from the navigator.</p>"},{"location":"transitions/#per-screen-transitions","title":"Per screen transitions","text":"<p>You can make a screen appear with a specific transition:</p> <pre><code>@Composable\nfun App(){\n    Navigator(HomeScreen)\n}\n\ndata object HomeScreen : Screen {\n\n    @Composable\n    override fun Content() {\n        val navigator = LocalNavigator.currentOrThrow\n\n        Button(\n            onClick = {\n                navigator.push(\n                    DetailsScreen(\n                        id = 1,\n                        onAppearTransition = SlideTransition.Horizontal.Appear\n                    )\n                )\n            }\n        ) {\n            Text(text = \"Show details\")\n        }\n    }\n}\n\ndata class DetailsScreen(val id: Long, override val onAppearTransition: ScreenTransition?) :\n    Screen {\n\n    @Composable\n    override fun Content() {\n        val navigator = LocalNavigator.currentOrThrow\n\n        Button(\n            onClick = {\n                navigator.pop()\n            }\n        ) {\n            Text(text = \"Go back\")\n        }\n    }\n}\n</code></pre>"},{"location":"transitions/#custom-transitions","title":"Custom transitions","text":"<p>You can create your own transitions by implementing the <code>ScreenTransition</code> interface.</p> <p>You can find source code for a working example here.</p>"},{"location":"work-in-progress/","title":"Work in progress","text":""},{"location":"work-in-progress/#ios-swipe-back","title":"iOS Swipe Back","text":"<p>You can find community solutions from Voyager in issue #144.</p>"},{"location":"work-in-progress/#predictive-back-animation","title":"Predictive back animation","text":"<p>You can find community solutions from Voyager in issue #144 and #223.</p>"},{"location":"work-in-progress/#result-passing-between-screens","title":"Result passing between screens","text":"<p>Coming very soon</p>"},{"location":"work-in-progress/#deep-linking","title":"Deep linking:","text":"<p>Best applied using community solutions:</p> <p>You can find community solutions from Voyager in issue #149 and #382</p>"},{"location":"navigation/","title":"Basic navigation","text":"<p>To set up basic navigation, simply implement the <code>Screen</code> interface for a data class or object. The <code>Content()</code> function of a <code>Screen</code> is used for displaying its contents.</p> <pre><code>data object HomeScreen : Screen {\n\n    @Composable\n    override fun Content() {\n        // ...\n    }\n}\n\ndata class DetailsScreen(val id: Long) : Screen {\n\n    @Composable\n    override fun Content() {\n        // ...\n    }\n}\n</code></pre> <p>Then anywhere in your composable logic call <code>Navigator()</code>, passing in its initial screens. A navigator is used to manage the screens you create. You can <code>push</code>, <code>pop</code> or <code>replace</code> screens within it.</p> <pre><code>@Composable\nfun App(){\n    Navigator(HomeScreen)\n}\n\ndata object HomeScreen : Screen {\n\n    @Composable\n    override fun Content() {\n        val navigator = LocalNavigator.currentOrThrow\n\n        Button(\n            onClick = {\n                navigator.push(DetailsScreen(1))\n                // navigator.replace(DetailsScreen(1)) is also possible\n                // \"replace\" removes the current screen and replaces it with the one specified.\n            }\n        ) {\n            Text(text = \"Show details\")\n        }\n    }\n}\ndata class DetailsScreen(val id: Long) : Screen {\n\n    @Composable\n    override fun Content() {\n        val navigator = LocalNavigator.currentOrThrow\n\n        Button(\n            onClick = {\n                navigator.pop()\n                // If we invoked \"replace\" on the current screen with this one instead of pushing, \"pop\" wouldn't do anything.\n            }\n        ) {\n            Text(text = \"Go back\")\n        }\n    }\n}\n</code></pre> <p>LocalNavigator is a function that returns the navigator that owns the current screen.</p> <p>You can find source code for a working example here.</p>"},{"location":"navigation/advanced-navigation/","title":"Advanced navigation","text":""},{"location":"navigation/advanced-navigation/#custom-rendering-position","title":"Custom rendering position","text":"<p>You can specify where exactly the current screen of a <code>Navigator</code> is rendered.</p> <p>This can be useful if you want to, for example, display a top bar above your screens.</p> <p>A call to <code>Navigator()</code> provides a <code>scope</code> where you can write additional composable logic that wraps its current screen. If you choose to use it, you must call <code>CurrentScreen</code> to render any contents:</p> <pre><code>@Composable\nfun App(){\n    Navigator(HomeScreen){ navigator -&gt;\n        Scaffold(\n            topBar = { /* ... */ },\n            content = { CurrentScreen(navigator) },\n        )\n    }\n}\n</code></pre>"},{"location":"navigation/advanced-navigation/#pass-arguments-to-the-current-screen-content","title":"Pass arguments to the current screen content","text":"<p>You may want to pass arguments to the contents of a screen, instead of its screen class.</p> <p>One of the cases where this can be useful is if you need to pass the <code>innerPadding</code> of a <code>Scaffold</code>.</p> <p>To do this, you can create your own screen interface that accepts the arguments you need:</p> <pre><code>interface ScaffoldScreen : Screen {\n\n    @Composable\n    fun Content(innerPadding: PaddingValues)\n\n    @Composable\n    override fun Content() {\n        error(\"Called Content without arguments\")\n    }\n}\n</code></pre> <p>And then cast the current screen to it, invoking its new <code>Content</code> function:</p> <pre><code>@Composable\nfun App(){\n    Navigator(HomeScreen){ navigator -&gt;\n        Scaffold(\n            topBar = { /* ... */ },\n            content = { innerPadding -&gt;\n                CurrentScreen(navigator){ currentScreen -&gt;\n                    (currentScreen as ScaffoldScreen).Content(innerPadding)\n                }\n            }\n        )\n    }\n}\n</code></pre>"},{"location":"navigation/advanced-navigation/#custom-back-handlers","title":"Custom back handlers","text":"<p>By default, any navigator has its own back handler which <code>pops</code> the current screen.</p> <p>You can opt out of this behaviour by setting the <code>defaultBackHandler</code> flag to <code>false</code>.</p> <p>You can then optionally create your own back handler:</p> <pre><code>@Composable\nfun App(){\n    Navigator(HomeScreen, defaultBackHandler = false){ navigator -&gt;\n\n        // Custom back handler   \n        BackHandler(enabled = /* ... */){\n            // ...\n        }\n\n        CurrentScreen(navigator)\n    }\n}\n</code></pre>"},{"location":"navigation/bottom-sheet-navigation/","title":"BottomSheet navigation","text":"<p>The only difference between basic navigation and bottom sheet navigation is that any <code>Navigator</code> inside a <code>BottomSheet</code> needs to have its <code>disposeOnForgotten</code> flag set to <code>true</code>. The flag is used to correctly dispose of the Navigator once it exits the composition. Necessary in ModalBottomSheets.</p> <pre><code>@Composable\nfun App() {\n    var showBottomSheet by remember {\n        mutableStateOf(false)\n    }\n\n    Box(\n        modifier = Modifier.fillMaxSize(),\n        contentAlignment = Alignment.Center,\n    ) {\n        Button(\n            onClick = {\n                showBottomSheet = true\n            }\n        ) {\n            Text(text = \"Show BottomSheet\")\n        }\n    }\n\n    if (showBottomSheet) {\n        ModalBottomSheet(\n            onDismissRequest = {\n                showBottomSheet = false\n            },\n        ) {\n            Navigator(FirstBottomSheetScreen, disposeOnForgotten = true)\n        }\n    }\n}\n</code></pre> <p>You can find source code for a working example here.</p>"},{"location":"navigation/nested-navigation/","title":"Nested navigation","text":"<p>There should be no issues if you need to set up some sort of nested navigation. Any navigator <code>N</code> with screen <code>B</code> created within screen <code>A</code> is <code>bound</code> to the lifecycle of screen <code>A</code>. If screen <code>A</code> happens to get disposed, navigator <code>N</code> and its screen <code>B</code> will also get disposed.</p> <pre><code>@Composable\nfun App(){\n    Navigator(ScreenA)\n}\n\ndata object ScreenA : Screen {\n\n    @Composable\n    override fun Content() {\n        Navigator(ScreenB)\n    }\n}\n\ndata object ScreenB : Screen {\n\n    @Composable\n    override fun Content() {\n        // ...\n    }\n}\n</code></pre> <p>You can call LocalNavigator.currentOrThrow.parent to access the navigator of the screen owning the current navigator.</p> <p>You can find source code for a working example here.</p>"},{"location":"navigation/tab-navigation/","title":"Tab navigation","text":"<p>Before reading this section it is advised to have read Advanced navigation.</p> <p>To set up tab navigation, simply implement the <code>Tab</code> interface for a data class or object.</p> <p>A <code>Tab</code> needs to have its own distinct index, and it\u2019s also a screen in itself. For example, like a <code>Screen</code>, it also has a <code>Content</code> function that is used for displaying its contents.</p> <pre><code>data object HomeTab : Tab {\n    override val index: UInt = 0u\n\n    @Composable\n    override fun Content() {\n        // ...\n    }\n}\n\ndata object ProfileTab : Tab {\n    override val index: UInt = 1u\n\n    @Composable\n    override fun Content() {\n        // ...\n    }\n}\n</code></pre> <p>Tabs, just like screens need to exist within a <code>Navigator</code>. But instead of <code>CurrentScreen</code> they need to be rendered with <code>CurrentTab</code>. You would most likely want to manage tabs within a <code>Scaffold</code>). Let\u2019s create a <code>Navigator</code> that manages tabs inside one.</p> <pre><code>@Composable\nfun App(){\n    Navigator(HomeTab) { navigator -&gt;\n        Scaffold(\n            content = {\n                CurrentTab(navigator)\n            },\n            bottomBar = {\n                NavigationBar {\n                    TabNavigationItem(HomeTab)\n                    TabNavigationItem(ProfileTab)\n                }\n            }\n        )\n    }\n}\n\n@Composable\nprivate fun RowScope.TabNavigationItem(tab: Tab) {\n    val navigator = LocalNavigator.currentOrThrow\n\n    val icon = when (tab.index) {\n        0u -&gt; rememberVectorPainter(Icons.Default.Home)\n        1u -&gt; rememberVectorPainter(Icons.Default.Person)\n        else -&gt; return\n    }\n\n    val title = when (tab.index) {\n        0u -&gt; \"Home\"\n        2u -&gt; \"Profile\"\n        else -&gt; return\n    }\n\n    NavigationBarItem(\n        selected = navigator.current == tab,\n        onClick = { navigator.current = tab },\n        icon = { Icon(painter = icon, contentDescription = title) }\n    )\n}\n</code></pre> <p>Tabs never get disposed until the screen owning the navigator they are in gets disposed.</p> <p>You can find source code for a working example here.</p>"},{"location":"screenmodel/","title":"ScreenModel","text":"<p>Vortex provides its own Multiplatform <code>ViewModel</code> called <code>ScreenModel</code>, which functions in the exact same way.</p> <pre><code>class HomeScreenModel : ScreenModel {\n\n    init {\n        screenModelScope.launch {\n            // ..\n        }\n    }\n\n    // Optional\n    override fun onDispose() {\n        // ...\n    }\n}\n</code></pre> <p>A <code>ScreenModel</code> can be bound to either the <code>Screen</code> it\u2019s in or a <code>Navigator</code>:</p> <pre><code>class HomeScreen : Screen {\n\n    @Composable\n    override fun Content() {\n        val screenModel = rememberScreenModel { HomeScreenModel() }\n        // ...\n        val navigator = LocalNavigator.currentOrThrow\n        val navigatorScreenModel = navigator.rememberNavigatorScreenModel { HomeScreenModel() }\n        // ...\n    }\n}\n</code></pre> <p>If you need to have multiple instances of the same <code>ScreenModel</code> for the same <code>Screen</code> or <code>Navigator</code>, you can add a tag to differentiate them.</p> <pre><code>val screenModel = rememberScreenModel(tag = \"CUSTOM_TAG\") { HomeScreenModel() }\n</code></pre>"},{"location":"screenmodel/#desktop-note","title":"Desktop Note","text":"<p>Note</p> <p>If you are targeting Desktop, you should provide the dependency <code>org.jetbrains.kotlinx:kotlinx-coroutines-swing</code>, the <code>screenModelScope</code> depends on <code>Dispatchers.Main</code> provided by this library on Desktop. We don\u2019t include it because this library is incompatible with IntelliJ Plugin, see. If you are targeting Desktop for IntelliJ plugins, this library does not require to be provided.</p> <p>You can find source code for a working example here.</p>"},{"location":"screenmodel/kodein-integration/","title":"Kodein integration","text":"<p>Success</p> <p>To use the <code>kodeinScreenModel</code> you should first import <code>io.github.hristogochev:vortex-kodein</code> (see Setup).</p> <p>Declare your <code>ScreenModel</code>s using the <code>bindProvider</code> bind.</p> <pre><code>val homeModule = DI.Module(name = \"home\") {\n    bindProvider { HomeScreenModel() } \n}\n</code></pre> <p>Call <code>kodeinScreenModel()</code> or <code>kodeinNavigatorScreenModel()</code> to get a new instance.</p> <pre><code>class HomeScreen : Screen {\n\n    @Composable\n    override fun Content() {\n        val screenModel = kodeinScreenModel&lt;HomeScreenModel&gt;()\n        // ...\n        val navigator = LocalNavigator.currentOrThrow\n        val navigatorScreenModel = navigator.kodeinNavigatorScreenModel&lt;HomeScreenModel&gt;()\n        // ...\n    }\n}\n</code></pre> <p>You can find source code for a working example here.</p>"},{"location":"screenmodel/koin-integration/","title":"Koin integration","text":"<p>Success</p> <p>To use the <code>koinScreenModel</code> you should first import <code>io.github.hristogochev:vortex-koin</code> (see Setup).</p> <p>Declare your <code>ScreenModel</code>s using the <code>factory</code> component.</p> <pre><code>val homeModule = module {\n    factory { HomeScreenModel() }\n}\n</code></pre> <p>Call <code>koinScreenModel()</code> or <code>koinNavigatorScreenModel()</code> to get a new instance.</p> <pre><code>class HomeScreen : Screen {\n\n    @Composable\n    override fun Content() {\n        val screenModel = koinScreenModel&lt;HomeScreenModel&gt;()\n        // ...\n        val navigator = LocalNavigator.currentOrThrow\n        val navigatorScreenModel = navigator.koinNavigatorScreenModel&lt;HomeScreenModel&gt;()\n        // ...\n    }\n}\n</code></pre> <p>You can find source code for a working example here.</p>"}]}